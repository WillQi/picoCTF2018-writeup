# The Vault

**Points:** 250

**Description**
> There is a website running at `http://2018shell1.picoctf.com:64349` ([link](http://2018shell1.picoctf.com:64349)). Try to see if you can login!

## Solution

We are given the source code of [/login.php](http://2018shell1.picoctf.com:64349/login.php) at the bottom of the index page, it can be found [here](http://2018shell1.picoctf.com:64349/login.txt).

We can see the query does not escape the input and is attackable using SQL injection.
```
$username = $_POST["username"];
$password = $_POST["password"];
$debug = $_POST["debug"];
$query = "SELECT 1 FROM users WHERE name='$username' AND password='$password'";
```

Further down the code we arrive at a validation check, it's job is to detect and prevent sql injections.
```
//validation check
$pattern ="/.*['\"].*OR.*/i";
$user_match = preg_match($pattern, $username);
$password_match = preg_match($pattern, $username);
if($user_match + $password_match > 0)  {
    echo "<h1>SQLi detected.</h1>";
}
else {
    $result = $con->query($query);
    $row = $result->fetchArray();

    if ($row) {
        echo "<h1>Logged in!</h1>";
        echo "<p>Your flag is: $FLAG</p>";
    } else {
        echo "<h1>Login failed.</h1>";
    }
}
```

If the user's input matches `/.*['\"].*OR.*/i`, the program will not run the query, and will echo `"<h1>SQLi detected.</h1>`. However the programmer made a mistake in their code.
```
$user_match = preg_match($pattern, $username);
$password_match = preg_match($pattern, $username);
```
The program only checks if we're trying to do a SQL injection attack using the username input, not the password input.

We can attack the website using an sql injection without being prevented if our sql injection is in the password input. If you type anything you want other than an sql injection in the username input, and type `' OR 1=1 OR '` for the password input. The website will echo the flag, which is `picoCTF{w3lc0m3_t0_th3_vau1t_e4ca2258}`.